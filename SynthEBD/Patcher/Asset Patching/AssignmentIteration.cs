using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SynthEBD
{
    /// <summary>
    /// Contains the permutation and asssociated data generated by one iteration of the GenerateCombination() function
    /// By tracking previously-generated combinations, the patcher avoids entering an infinite loop of re-generating combinations trying to find one that satisfied subgroup and bodygen constraints
    /// </summary>
    class AssignmentIteration
    {
        public AssignmentIteration()
        {
            this.ChosenSeed = null;
            this.ChosenAssetPack = null;
            this.RemainingVariantsByIndex = new Dictionary<int, FlattenedAssetPack>();
            this.PreviouslyGeneratedCombinations = new HashSet<string>();
        }
        public FlattenedSubgroup ChosenSeed { get; set; }
        public FlattenedAssetPack ChosenAssetPack { get; set; }
        public Dictionary<int, FlattenedAssetPack> RemainingVariantsByIndex { get; set; }
        public HashSet<string> PreviouslyGeneratedCombinations = new HashSet<string>();

        public static int BackTrack(AssignmentIteration iterationInfo, FlattenedSubgroup toRemove, int currentIndex, int steps)
        {
            FlattenedAssetPack revertTo = iterationInfo.RemainingVariantsByIndex[currentIndex - steps];
            if (toRemove != null)
            {
                revertTo.Subgroups[currentIndex - steps].Remove(toRemove);
            }
            iterationInfo.ChosenAssetPack = revertTo;

            return currentIndex - steps - 1; // -1 because the calling for loop will then immediately add 1 back at the next iteration
        }
    }
}
