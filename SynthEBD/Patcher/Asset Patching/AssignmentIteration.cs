using System.Collections.Generic;

namespace SynthEBD
{
    /// <summary>
    /// Contains the permutation and asssociated data generated by one iteration of the GenerateCombination() function
    /// By tracking previously-generated combinations, the patcher avoids entering an infinite loop of re-generating combinations trying to find one that satisfied subgroup and bodygen constraints
    /// </summary>
    class AssignmentIteration
    {
        public AssignmentIteration()
        {
            this.AvailableSeeds = new List<FlattenedSubgroup>();
            this.ChosenSeed = null;
            this.ChosenAssetPack = null;
            this.RemainingVariantsByIndex = new Dictionary<int, FlattenedAssetPack>();
            this.PreviouslyGeneratedCombinations = new HashSet<string>();
        }
        public List<FlattenedSubgroup> AvailableSeeds { get; set; }
        public FlattenedSubgroup ChosenSeed { get; set; }
        public FlattenedAssetPack ChosenAssetPack { get; set; }
        public Dictionary<int, FlattenedAssetPack> RemainingVariantsByIndex { get; set; }
        public HashSet<string> PreviouslyGeneratedCombinations = new HashSet<string>();

        public static int BackTrack(AssignmentIteration iterationInfo, SubgroupCombination currentCombination, int currentIndex, int steps)
        {
            FlattenedAssetPack revertTo = iterationInfo.RemainingVariantsByIndex[currentIndex - steps];
            FlattenedSubgroup ToRemove = currentCombination.ContainedSubgroups[currentIndex - steps];
            if (ToRemove != null)
            {
                revertTo.Subgroups[currentIndex - steps].Remove(ToRemove);
            }
            iterationInfo.ChosenAssetPack = revertTo;
            currentCombination.ContainedSubgroups[currentIndex - steps] = null;

            return currentIndex - steps - 1; // -1 because the calling for loop will then immediately add 1 back at the next iteration
        }
    }
}
