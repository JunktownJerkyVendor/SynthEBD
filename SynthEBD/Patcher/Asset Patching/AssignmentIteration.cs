using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SynthEBD
{
    /// <summary>
    /// Contains the permutation and asssociated data generated by one iteration of the GenerateCombination() function
    /// By tracking previously-generated combinations, the patcher avoids entering an infinite loop of re-generating combinations trying to find one that satisfied subgroup and bodygen constraints
    /// </summary>
    class AssignmentIteration
    {
        public AssignmentIteration()
        {
            this.ChosenSeed = null;
            this.ChosenAssetPack = null;
            this.RemainingVariantsByIndex = new Dictionary<int, FlattenedAssetPack>();
            this.PreviouslyGeneratedCombinations = new HashSet<string>();
        }
        public FlattenedSubgroup ChosenSeed { get; set; }
        public FlattenedAssetPack ChosenAssetPack { get; set; }
        public Dictionary<int, FlattenedAssetPack> RemainingVariantsByIndex { get; set; }
        public HashSet<string> PreviouslyGeneratedCombinations = new HashSet<string>();

        public static int BackTrack(AssignmentIteration iterationInfo, FlattenedSubgroup toRemove, int currentIndex, bool removeFromPreviousindex, bool additionalDecrement)
        {
            FlattenedAssetPack revertTo;
            switch (removeFromPreviousindex)
            {
                case false:
                    revertTo = iterationInfo.RemainingVariantsByIndex[currentIndex];

                    if (toRemove != null)
                    {
                        revertTo.Subgroups[currentIndex].Remove(toRemove);
                    }
                    break;

                case true:
                    revertTo = iterationInfo.RemainingVariantsByIndex[currentIndex - 1];

                    if (toRemove != null && currentIndex - 1 >= 0)
                    {
                        revertTo.Subgroups[currentIndex - 1].Remove(toRemove);
                    }
                    break;
            }

            iterationInfo.ChosenAssetPack = revertTo.ShallowCopy();

            int returnIndex = currentIndex - 1;
            if (additionalDecrement)
            {
                returnIndex--;
            }

            return returnIndex;
        }
    }
}
